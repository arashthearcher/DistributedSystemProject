\section{Approach}

The ultimate goal of this project is to infer invariants in a
distributed system. For the scope of this project we will consider a
system with 2 nodes. Before inferring invariants we need to identify
likely distributed state variables. We define distributed state
variables, as variables that are stored in one node whose values are
affected or determined by the other remote node in the distributed
system. It should be noted that these variables are only a part of the
state in a distributed system at a given time. For our case we assume
that these capture a significant portion of the state. Consider the
code samples Listing~\ref{lst:node0} and Listing~\ref{lst:node1}
showing the communication between two nodes in a distributed system.
This conversation is depicted visually in
Figure~\ref{fig:sample_code_diag}. Here it will be useful to to infer
the equality between elements in each pair \texttt{(a,first),
(b,second),(sum,result)} and also the properites: \texttt{(result = a
+ b)} and \texttt{(sum = first + second)}.


\begin{figure}
  \includegraphics[width=\columnwidth]{sample_code.pdf}
  \caption{Example communication between two nodes in a distributed system}
  \label{fig:sample_code_diag}
\end{figure}

\begin{figure}
\begin{lstlisting}[caption={Sample code for Communication between 2 nodes - Node 0}, label=lst:node0]
    Integer a := 1
    Integer b := 2
    send ( a + '_' + b )
    recv (buf)
    Integer result := parse (buf)
\end{lstlisting}
\end{figure}

\begin{figure}
\begin{lstlisting}[caption={Sample code for Communication between 2 nodes - Node 1}, label=lst:node1]
    recv (buf)
    Integer first := getFirstOperand( buf )
    Integer second := getSecondOperand( buf )
    Integer sum := first + second
    send ( sum )
\end{lstlisting}
\end{figure}

The naive approach for inferring these invariants will be to dump all
state varaible values at all program points and feed them to an
invariant detector like daikon\cite{ernst2007daikon}. But given the
number of program points and huge number of variables in a relatively
large program this approach is not scalable. So we propose two main
optimizations to reduce the number of program point, variable value
combinations.

\subsection{Detecting interesting program points}

Rather than dumping state at all program points we expect the
developer to mark interesting program points using annotations. The
program state will be dumped at only these annotated points. This will
also help to narrow down the focus to points that are identified by
the developer as interesting points without wasting resources
analyzing useless program points. The annotations will be identified
by the parser at the instrumentation phase and re-written to include
statements which will write the values of variable to a file when the
program reaches that point in the runtime.

Since there can be multiple points annotated in a program by a
developer, vector clocks will be used to partially order annotation
pairs in the two programs. This will also help to invalidate
annotations inserted at irrelevant locations by the developer.

\subsection{Dataflow analysis for Go programs}

Even at interesting program points, variable space that need to be
captured is very large. So only the variables that were affected by
the communication with other nodes need to be identified. To detect
these variables, some form of dataflow analysis is required. This
includes the dataflow of the distributed system as a whole and also in
a single program. For example using a forward flow analysis on Listing~\ref{lst:node1} we can say that \texttt{sum} variable at line 4 and line 5 is affected by the \texttt{buf} variable at line 1. But currently there are no data flow analysis
frameworks specifically for Go programs.

So we are planning to do a dynamic dataflow analysis which consists of following steps:
\begin{itemize}
\item Instrumenting variable declarations and assignments at the run time
\item Collecting execution traces of each of these statements by runnning test suites
\item Doing a forward flow analysis using the collected traces
\end{itemize}

This dynamic analysis approach was chosen because it gives information about the actual execution and therefore is more accurate. And also compared to using a static analysis-based approach, this approach makes it easier to handle Go language-specific constructs like channels which are used share data between goroutines. Only drawback in this approach is, it only examines the paths invoked during execution, unlike static analysis which can be used to reason about all possible execution paths and variable values. To compensate for that we are planning to use a comprehnsive test suite with good test coverage.

% This is a challenging problem in itself because Go language has
% special constructs like channels to share data between goroutines. We
% are planning to do this analysis dynamically by instrumenting variable
% declarations and assignments, and then collecting execution traces of
% each of these statements. We have chosen this approach because it
% gives information about the actual execution and therefore is more
% accurate. For this we are hoping to use static analysis libraries
% available under Go-lang tools\cite{static_golang} which provide
% support for Identifier resolution, Type information, Call graph
% navigation and Channel peers (send $\leftrightarrow$ receive)
% identification.

% Our dynamic dataflow analysis is focused on mainly providing the
% following features. Given a variable, start line and end line it will
% return a set of variables affected by that variable between start line
% and the end line.

% As the next phase of our project, using the above analysis, we hope to
% find out variables affected by receiving messages in interprocess
% communication channels like RPC and TCP/UDP sockets. We will get the
% values of these variables just before another send/receive or end of
% function whichever occurs first. We assume these set of variables at
% the send statement in both (sending and receiving) nodes taken
% together represent global state of the distributed system.

% Given two nodes which are communicating we have two such sets of
% variables representing a particular state. So we will select the
% corresponding variable pairs from send and receive of each node
% mentioned in the previous step and provide as inputs for the Daikon
% invariant detector. This will give us a set of properties that were
% true over the observed executions across 2 nodes. Overall execution
% flow of the analysis is shown in Figure~\ref{fig:go_flow}.

Overall execution flow of the analysis is illustrated in Figure~\ref{fig:go_flow} and works as follows:
\begin{itemize}
\item Developer annotates interesting program points in the Go program which will be used as states for mining invariants.
\item Program is instrumented to 
\begin{itemize}
\item dump variable values at the annotated program points at run time
\item wrap all RPC communication to include vector clocks
\item log all declarations and assignments for doing the forward flow analysis
\end{itemize}
 For this we are hoping to use static analysis libraries
available under Go-lang Parse package and tools\cite{static_golang} which provide
support for Identifier resolution, Type information, Call graph
navigation and Channel peers (send $\leftrightarrow$ receive)
identification.
\item Then as the first step in the analysis phase, this instrumented program is executed using the test suites and program traces are collected.
\item Forward flow analysis is done on the collected traces
\item Using the results of the previous step, variables contributing to distributed state is identified.
\item From the dumped variable values at annotated program points (after multiple executions), only the values of variables chosen in the previous step are selected.
\item Selected variable values belonging to 2 distinct annotated program points in the 2 nodes are fed to Daikon for inferring invariants.
\end{itemize}


\begin{figure}
  \includegraphics[width=\columnwidth]{go_flow.pdf}
  \caption{Flow of the invariant inference of Go programs}
  \label{fig:go_flow}
\end{figure}

\section{Timeline}

Following is the planned milestones and estimated timeline for the project completion.

\begin{description}
  \item[2/10:] Proposal Draft Submission
  \item[3/3:] Proposal Submission
  \item[3/7:] Finalizing the design, Familirization with required tools (Daikon, Go source analysis tools)
  \item[3/14:] Implementation - Go program instrumentation to handle annotations and dumping state
  \item[3/21:] Implementation - Dynamic Forward Analysis for Go programs
  \item[3/28:] Implementation - Vector clocks integration and end-to-end working analysis
  \item[4/4:] Evaluation - Inferring invariants in test programs
  \item[4/7:] Project Presentation
  \item[4/16:] Project Code and Report Submission
\end{description}