\subsection{Implementation Details}

In this section we explain the details of prototype of our approach implemented in Go programming language.

\subsubsection{Program Instrumenter}

We used Golang's \texttt{go/ast} package to parse the input program and construct the abstract syntax tree. Then we traverse this tree and collect informations about location of \texttt{//@dump} annotations and send and receive functions. Then we added the required functions for logging the variables to the source code of the program and replaced annotations with appropriate function calls to log distributed state variables of the system. 

\subsubsection{Program Slicer}

Go program slicer is built on top of CFG and reaching definitions computed as part of Go Doctor (The Golang Refactoring Engine) project \cite{godoctor}. Also, some code snippets from Go static single-assignment (SSA) package \cite{ssa} is used to compute dominance tree from CFG. After building PDG, reachability of nodes from start node is determined via a breadth-first search on the graph.



\section{Evaluation}
We implemented our approach in a tool in Go programming language. We evaluated our tool by verifying correctness of pseudo-two-phase commit of figure \ref{lst:2pc} and example program of figure \ref{fig:exampleprog}. Our tool was able to infer the expected invariants in both of these programs. Also, different components of our tool such as program slicer, instrumenter and log merger have been tested in isolation to ensure correctness of the prototype. It is worth mentioning, that our prototype currently only handles scalar variables but extending it to handle structs is only an extra engineering effort. %We also do not perform interprocedural data and control flow analysis, so we always log all global variables and 

\section{Related Work}

Yabandeh et al.\cite{yabandeh2011finding} proposed an approach to
infer almost-invariants in distributed systems. They infer the
invariants that are true in most cases and assume these invariants
only get violated due to manifestation of bugs. There are a number of
ways our approach differ from theirs: Their approach requires user to
provide a list of variables and functions that they want to consider
for inferring invariants while our approach infers distributed state
variables automatically. Moreover, they assume that an external module
generates a trace of globally consistent state system for their
algorithm while our approach extract these states through dynamic
execution of the distributed system.

Ernst et al.\cite{ernst2001dynamically} infer invariants in a
sequential program by executing the program on a collection of inputs.
This invariant detector has been released as a tool called
Daikon\cite{ernst2007daikon}. Although, we use their tool to infer
invariants, detecting invariants in a distributed system poses unique
challenges to identify distributed state and valid global states among
a larger set of variables. Ne Win et al.\cite{NeWinEGKL04} use daikon
to assist theorem provers for verifying distributed algorithms. To
demonstrate their approach, they proved the correctness of the Paxos
algorithm.

Beschastnikh et al. \cite{temporalInv} infer temporal invariants from partially ordered logs of the distributed system. By using logs of the system, they put the responsibility on developers to decide which portion of the state of the program can be used to infer invariants. Although, we require developers to specify at which points in the program invariants can be checked, we infer the portion of the state that can be checked for invariants automatically with data flow analysis.


\section{Acknowledgment}
We would like to thank Ivan Beschastnikh for his valuable insight and feedback on proposal of this project.