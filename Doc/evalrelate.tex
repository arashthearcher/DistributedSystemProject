\subsection{Implementation}

\subsubsection{Program Slicer}

Go program slicer is built on top of CFG and reaching definitions computed as part of Go Doctor (The Golang Refactoring Engine) project \cite{godoctor}. Also, some code snippets from Go static single-assignment (SSA) package \cite{ssa} is used to compute dominance tree from CFG. After building PDG, reachability of nodes from start node is determined via a breadth-first search on the graph.



\section{Results}
We will implement our approach in a tool in Go programming language. We plan to evaluate our tool by verifying correctness of two-phase commit and leader election protocols. Our tool should be able to infer safety property of both algorithms. In two-phase commit protocol all nodes should perform the same action (commit or abort) so our tool should infer this property. In leader election algorithm there should be only one leader (uniqueness property) and at the end of protocol execution all nodes should know ID of the leader (agreement property). It is worth mentioning that our approach is not suitable for checking the liveness properties of these algorithms.

\section{Related Work}

Yabandeh et al.\cite{yabandeh2011finding} proposed an approach to
infer almost-invariants in distributed systems. They infer the
invariants that are true in most cases and assume these invariants
only get violated due to manifestation of bugs. There are a number of
ways our approach differ from theirs: Their approach requires user to
provide a list of variables and functions that they want to consider
for inferring invariants while our approach infers distributed state
variables automatically. Moreover, they assume that an external module
generates a trace of globally consistent state system for their
algorithm while our approach extract these states through dynamic
execution of the distributed system.

Ernst et al.\cite{ernst2001dynamically} infer invariants in a
sequential program by executing the program on a collection of inputs.
This invariant detector has been released as a tool called
Daikon\cite{ernst2007daikon}. Although, we use their tool to infer
invariants, detecting invariants in a distributed system poses unique
challenges to identify distributed state and valid global states among
a larger set of variables. Ne Win et al.\cite{NeWinEGKL04} use daikon
to assist theorem provers for verifying distributed algorithms. To
demonstrate their approach, they proved the correctness of the Paxos
algorithm.

Beschastnikh et al. \cite{temporalInv} infer temporal invariants from partially ordered logs of the distributed system. By using logs of the system, they put the responsibility on developers to decide which portion of the state of the program can be used to infer invariants. Although, we require developers to specify at which points in the program invariants can be checked, we infer the portion of the state that can be checked for invariants automatically with data flow analysis.


\section{Acknowledgment}
We would like to thank Ivan Beschastnikh for his valuable insight and feedback on initial draft of this proposal.